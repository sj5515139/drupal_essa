<?php

/**
 * @file
 * Enables the organization of content into categories.
 */

/**
 * Users can create new terms in a free-tagging vocabulary when
 * submitting a dnp_autocomplete_widget. We store a term object
 * whose tid is 'autocreate' as a field data item during widget
 * validation and then actually create the term if/when that field
 * data item makes it to dnp_field_insert/update().
 */

/**
 * Implements hook_help().
 */
function dnp_help($path, $arg) {
  switch ($path) {
    case 'admin/help#dnp':
      $output = '';
      $output .= '<h3>' . t('About') . '</h3>';
      $output .= '<p>' . t('The dnp module allows you to classify the content of your website. To classify content, you define <em>vocabularies</em> that contain related <em>terms</em>, and then assign the vocabularies to content types. For more information, see the online handbook entry for the <a href="@dnp">dnp module</a>.', array('@dnp' => 'http://drupal.org/documentation/modules/dnp/')) . '</p>';
      $output .= '<h3>' . t('Uses') . '</h3>';
      $output .= '<dl>';
      $output .= '<dt>' . t('Creating vocabularies') . '</dt>';
      $output .= '<dd>' . t('Users with sufficient <a href="@perm">permissions</a> can create <em>vocabularies</em> and <em>terms</em> through the <a href="@taxo">dnp page</a>. The page listing the terms provides a drag-and-drop interface for controlling the order of the terms and sub-terms within a vocabulary, in a hierarchical fashion. A <em>controlled vocabulary</em> classifying music by genre with terms and sub-terms could look as follows:', array('@taxo' => url('admin/structure/dnp'), '@perm' => url('admin/people/permissions', array('fragment'=>'module-dnp'))));
      $output .= '<ul><li>' . t('<em>vocabulary</em>: Music') . '</li>';
      $output .= '<ul><li>' . t('<em>term</em>: Jazz') . '</li>';
      $output .= '<ul><li>' . t('<em>sub-term</em>: Swing') . '</li>';
      $output .= '<li>' . t('<em>sub-term</em>: Fusion') . '</li></ul></ul>';
      $output .= '<ul><li>' . t('<em>term</em>: Rock') . '</li>';
      $output .= '<ul><li>' . t('<em>sub-term</em>: Country rock') . '</li>';
      $output .= '<li>' . t('<em>sub-term</em>: Hard rock') . '</li></ul></ul></ul>';
      $output .= t('You can assign a sub-term to multiple parent terms. For example, <em>fusion</em> can be assigned to both <em>rock</em> and <em>jazz</em>.') . '</dd>';
      $output .= '<dd>' . t('Terms in a <em>free-tagging vocabulary</em> can be built gradually as you create or edit content. This is often done used for blogs or photo management applications.') . '</dd>';
      $output .= '<dt>' . t('Assigning vocabularies to content types') . '</dt>';
      $output .= '<dd>' . t('Before you can use a new vocabulary to classify your content, a new dnp term field must be added to a <a href="@ctedit">content type</a> on its <em>manage fields</em> page. When adding a dnp field, you choose a <em>widget</em> to use to enter the dnp information on the content editing page: a select list, checkboxes, radio buttons, or an auto-complete field (to build a free-tagging vocabulary). After choosing the field type and widget, on the subsequent <em>field settings</em> page you can choose the desired vocabulary, whether one or multiple terms can be chosen from the vocabulary, and other settings. The same vocabulary can be added to multiple content types, by using the "Add existing field" section on the manage fields page.', array('@ctedit' => url('admin/structure/types'))) . '</dd>';
      $output .= '<dt>' . t('Classifying content') . '</dt>';
      $output .= '<dd>' . t('After the vocabulary is assigned to the content type, you can start classifying content. The field with terms will appear on the content editing screen when you edit or <a href="@addnode">add new content</a>.', array('@addnode' => url('node/add'))) . '</dd>';
      $output .= '<dt>' . t('Viewing listings and RSS feeds by term') . '</dt>';
      $output .= '<dd>' . t("Each dnp term automatically provides a page listing content that has its classification, and a corresponding RSS feed. For example, if the dnp term <em>country rock</em> has the ID 123 (you can see this by looking at the URL when hovering on the linked term, which you can click to navigate to the listing page), then you will find this list at the path <em>dnp/term/123</em>. The RSS feed will use the path <em>dnp/term/123/feed</em> (the RSS icon for this term's listing will automatically display in your browser's address bar when viewing the listing page).") . '</dd>';
      $output .= '<dt>' . t('Extending dnp module') . '</dt>';
      $output .= '<dd>' . t('There are <a href="@taxcontrib">many contributed modules</a> that extend the behavior of the dnp module for both display and organization of terms.', array('@taxcontrib' => 'http://drupal.org/project/modules?filters=tid:71&solrsort=sis_project_release_usage%20desc'));
      $output .= '</dl>';
      return $output;
    case 'admin/structure/dnp':
      $output = '<p>' . t('Management is the integral part of any organisation. Manage the Departments and Posts here. This will help you manage the system efficiently. Posts will help you manage the permission sets, while Departments will create different groups. The entire mechanism will help you synergize your affair. The hierarchy will facilitate various system features like Leave management system and other approval related mechanisms.') . '</p>';
      return $output;
    case 'admin/structure/dnp/%':
      $vocabulary = dnp_vocabulary_machine_name_load($arg[3]);
      switch ($vocabulary->hierarchy) {
        case 0:
          return '<p>' . t('You can reorganize the terms in %capital_name using their drag-and-drop handles, and group terms under a parent term by sliding them under and to the right of the parent.', array('%capital_name' => drupal_ucfirst($vocabulary->name), '%name' => $vocabulary->name)) . '</p>';
        case 1:
          return '<p>' . t('%capital_name contains terms grouped under parent terms. You can reorganize the terms in %capital_name using their drag-and-drop handles.', array('%capital_name' => drupal_ucfirst($vocabulary->name), '%name' => $vocabulary->name)) . '</p>';
        case 2:
          return '<p>' . t('%capital_name contains terms with multiple parents. Drag and drop of terms with multiple parents is not supported, but you can re-enable drag-and-drop support by editing each term to include only a single parent.', array('%capital_name' => drupal_ucfirst($vocabulary->name))) . '</p>';
      }
  }
}

/**
 * Implements hook_permission().
 */
function dnp_permission() {
  $permissions = array(
    'administer dnp' => array(
      'title' => t('Administer vocabularies and terms'),
    ),
  );
 
//RT21
$permissions += array(
       'hide structure'=> array(
         'title' => t('hide structure'),
      ),
    );
	



 foreach (dnp_get_vocabularies() as $vocabulary) {
    $permissions += array(
      'edit terms in ' . $vocabulary->vid => array(
        'title' => t('Edit terms in %vocabulary', array('%vocabulary' => $vocabulary->name)),
      ),
    );
    $permissions += array(
       'delete terms in ' . $vocabulary->vid => array(
         'title' => t('Delete terms from %vocabulary', array('%vocabulary' => $vocabulary->name)),
      ),
    );
  }
  return $permissions;
}

/**
 * Implements hook_entity_info().
 */
function dnp_entity_info() {
  $return = array(
    'dnp_term' => array(
      'label' => t('dnp term'),
      'controller class' => 'dnpTermController',
      'base table' => 'dnp_term_data',
      'uri callback' => 'dnp_term_uri',
      'fieldable' => TRUE,
      'entity keys' => array(
        'id' => 'tid',
        'bundle' => 'vocabulary_machine_name',
        'label' => 'name',
      ),
      'bundle keys' => array(
        'bundle' => 'machine_name',
      ),
      'bundles' => array(),
      'view modes' => array(
        // @todo View mode for display as a field (when attached to nodes etc).
        'full' => array(
          'label' => t('dnp term page'),
          'custom settings' => FALSE,
        ),
      ),
    ),
  );
  foreach (dnp_vocabulary_get_names() as $machine_name => $vocabulary) {
    $return['dnp_term']['bundles'][$machine_name] = array(
      'label' => $vocabulary->name,
      'admin' => array(
        'path' => 'admin/structure/dnp/%dnp_vocabulary_machine_name',
        'real path' => 'admin/structure/dnp/' . $machine_name,
        'bundle argument' => 3,
        'access arguments' => array('administer dnp'),
      ),
    );
  }
  $return['dnp_vocabulary'] = array(
    'label' => t('dnp vocabulary'),
    'controller class' => 'dnpVocabularyController',
    'base table' => 'dnp_vocabulary',
    'entity keys' => array(
      'id' => 'vid',
      'label' => 'name',
    ),
    'fieldable' => FALSE,
  );

  return $return;
}

/**
 * Implements callback_entity_info_uri().
 */
function dnp_term_uri($term) {
  return array(
    'path' => 'dnp/term/' . $term->tid,
  );
}

/**
 * Implements hook_field_extra_fields().
 */
function dnp_field_extra_fields() {
  $return = array();
  $info = entity_get_info('dnp_term');
  foreach (array_keys($info['bundles']) as $bundle) {
    $return['dnp_term'][$bundle] = array(
      'form' => array(
        'name' => array(
          'label' => t('Name'),
          'description' => t('Term name textfield'),
          'weight' => -5,
        ),
        'description' => array(
          'label' => t('Description'),
          'description' => t('Term description textarea'),
          'weight' => 0,
        ),
      ),
      'display' => array(
        'description' => array(
          'label' => t('Description'),
          'description' => t('Term description'),
          'weight' => 0,
        ),
      ),
    );
  }

  return $return;
}

/**
 * Return nodes attached to a term across all field instances.
 *
 * This function requires dnp module to be maintaining its own tables,
 * and will return an empty array if it is not. If using other field storage
 * methods alternatives methods for listing terms will need to be used.
 *
 * @param $tid
 *   The term ID.
 * @param $pager
 *   Boolean to indicate whether a pager should be used.
 * @param $limit
 *   Integer. The maximum number of nodes to find.
 *   Set to FALSE for no limit.
 * @param $order
 *   An array of fields and directions.
 *
 * @return
 *   An array of nids matching the query.
 */
function dnp_select_nodes($tid, $pager = TRUE, $limit = FALSE, $order = array('t.sticky' => 'DESC', 't.created' => 'DESC')) {
  if (!variable_get('dnp_maintain_index_table', TRUE)) {
    return array();
  }
  $query = db_select('dnp_index', 't');
  $query->addTag('node_access');
  $query->condition('tid', $tid);
  if ($pager) {
    $count_query = clone $query;
    $count_query->addExpression('COUNT(t.nid)');

    $query = $query->extend('PagerDefault');
    if ($limit !== FALSE) {
      $query = $query->limit($limit);
    }
    $query->setCountQuery($count_query);
  }
  else {
    if ($limit !== FALSE) {
      $query->range(0, $limit);
    }
  }
  $query->addField('t', 'nid');
  $query->addField('t', 'tid');
  foreach ($order as $field => $direction) {
    $query->orderBy($field, $direction);
    // ORDER BY fields need to be loaded too, assume they are in the form
    // table_alias.name
    list($table_alias, $name) = explode('.', $field);
    $query->addField($table_alias, $name);
  }
  return $query->execute()->fetchCol();
}

/**
 * Implements hook_theme().
 */
function dnp_theme() {
  return array(
    'dnp_overview_vocabularies' => array(
      'render element' => 'form',
    ),
    'dnp_overview_terms' => array(
      'render element' => 'form',
    ),
    'dnp_term' => array(
      'render element' => 'elements',
      'template' => 'dnp-term',
    ),
  );
}

/**
 * Implements hook_menu().
 */
function dnp_menu() {

 $items['admin/structure/dnp'] = array(
    'title' => 'Departments and Posts',
    'description' => 'Manage tagging, categorization, and classification of your content.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('dnp_overview_vocabularies'),
    'access arguments' => array('administer dnp'),
    'file' => 'dnp.admin.inc',
  );
  
  
  $items['admin/structure/dnp/list'] = array(
    'title' => 'List',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );
 
  $items['dnp/term/%dnp_term'] = array(
    'title' => 'dnp term',
    'title callback' => 'dnp_term_title',
    'title arguments' => array(2),
    'page callback' => 'dnp_term_page',
    'page arguments' => array(2),
    'access arguments' => array('access content'),
    'file' => 'dnp.pages.inc',
  );
  $items['dnp/term/%dnp_term/view'] = array(
    'title' => 'View',
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );
  $items['dnp/term/%dnp_term/edit'] = array(
    'title' => 'Edit',
    'page callback' => 'drupal_get_form',
    // Pass a NULL argument to ensure that additional path components are not
    // passed to dnp_form_term() as the vocabulary machine name argument.
    'page arguments' => array('dnp_form_term', 2, NULL),
    'access callback' => 'dnp_term_edit_access',
    'access arguments' => array(2),
    'type' => MENU_LOCAL_TASK,
    'weight' => 10,
    'file' => 'dnp.admin.inc',
  );
  $items['dnp/term/%dnp_term/feed'] = array(
    'title' => 'dnp term',
    'title callback' => 'dnp_term_title',
    'title arguments' => array(2),
    'page callback' => 'dnp_term_feed',
    'page arguments' => array(2),
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
    'file' => 'dnp.pages.inc',
  );
  $items['dnp/autocomplete'] = array(
    'title' => 'Autocomplete dnp',
    'page callback' => 'dnp_autocomplete',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
    'file' => 'dnp.pages.inc',
  );

  $items['admin/structure/dnp/%dnp_vocabulary_machine_name'] = array(
    //'title' => 'School Setup Wizard(Academics) - Step 7 of 12',
		'title callback' => 'entity_label',
  	'title arguments' => array('dnp_vocabulary', 3),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('dnp_overview_terms', 3),
    'access arguments' => array('administer dnp'),
    'file' => 'dnp.admin.inc',
  );
  
  $items['admin/structure/dnp/%dnp_vocabulary_machine_name/adddepartment'] = array(
    'title' => 'Add Department',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('dnp_form_term', array(), 3),
    'access arguments' => array('administer dnp'),
    'type' => MENU_LOCAL_ACTION,
    'file' => 'dnp.admin.inc',
  );

  
   $items['admin/structure/dnp/%dnp_vocabulary_machine_name/addpost'] = array(
    'title' => 'Add Posts',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('dnp_form_term_post', array(), 3),
    'access arguments' => array('administer dnp'),
    'type' => MENU_LOCAL_ACTION,
    'file' => 'dnp.admin.inc',
  );
  return $items;
}

/**
 * Implements hook_admin_paths().
 */
function dnp_admin_paths() {
  $paths = array(
    'dnp/term/*/edit' => TRUE,
  );
  return $paths;
}

/**
 * Return edit access for a given term.
 */
function dnp_term_edit_access($term) {
  return user_access("edit terms in $term->vid") || user_access('administer dnp');
}

/**
 * Returns the sanitized name of a vocabulary.
 *
 * Deprecated. This function was previously used as a menu item title callback
 * but has been replaced by using entity_label() (which does not
 * sanitize the title, since the menu system does that automatically). In
 * Drupal 7, use that function for title callbacks, and call check_plain()
 * directly if you need a sanitized title.
 */
function dnp_admin_vocabulary_title_callback($vocabulary) {
  return check_plain($vocabulary->name);
}

/**
 * Saves a vocabulary.
 *
 * @param $vocabulary
 *   A vocabulary object with the following properties:
 *   - vid: (optional) The ID of the vocabulary (omit if creating a new
 *     vocabulary; only use to update an existing vocabulary).
 *   - name: The human-readable name of the vocabulary.
 *   - machine_name: The machine name of the vocabulary.
 *   - description: (optional) The vocabulary's description.
 *   - hierarchy: The hierarchy level of the vocabulary.
 *   - module: (optional) The module altering the vocabulary.
 *   - weight: (optional) The weight of this vocabulary in relation to other
 *     vocabularies.
 *   - original: (optional) The original vocabulary object before any changes
 *     are applied.
 *   - old_machine_name: (optional) The original machine name of the
 *     vocabulary.
 *
 * @return
 *   Status constant indicating whether the vocabulary was inserted (SAVED_NEW)
 *   or updated (SAVED_UPDATED).
 */
function dnp_vocabulary_save($vocabulary) {
  // Prevent leading and trailing spaces in vocabulary names.
  if (!empty($vocabulary->name)) {
    $vocabulary->name = trim($vocabulary->name);
  }
  // Load the stored entity, if any.
  if (!empty($vocabulary->vid)) {
    if (!isset($vocabulary->original)) {
      $vocabulary->original = entity_load_unchanged('dnp_vocabulary', $vocabulary->vid);
    }
    // Make sure machine name changes are easily detected.
    // @todo: Remove in Drupal 8, as it is deprecated by directly reading from
    // $vocabulary->original.
    $vocabulary->old_machine_name = $vocabulary->original->machine_name;
  }

  if (!isset($vocabulary->module)) {
    $vocabulary->module = 'dnp';
  }

  module_invoke_all('dnp_vocabulary_presave', $vocabulary);
  module_invoke_all('entity_presave', $vocabulary, 'dnp_vocabulary');

  if (!empty($vocabulary->vid) && !empty($vocabulary->name)) {
    $status = drupal_write_record('dnp_vocabulary', $vocabulary, 'vid');
    dnp_vocabulary_static_reset(array($vocabulary->vid));
    if ($vocabulary->old_machine_name != $vocabulary->machine_name) {
      field_attach_rename_bundle('dnp_term', $vocabulary->old_machine_name, $vocabulary->machine_name);
    }
    module_invoke_all('dnp_vocabulary_update', $vocabulary);
    module_invoke_all('entity_update', $vocabulary, 'dnp_vocabulary');
  }
  elseif (empty($vocabulary->vid)) {
    $status = drupal_write_record('dnp_vocabulary', $vocabulary);
    dnp_vocabulary_static_reset();
    field_attach_create_bundle('dnp_term', $vocabulary->machine_name);
    module_invoke_all('dnp_vocabulary_insert', $vocabulary);
    module_invoke_all('entity_insert', $vocabulary, 'dnp_vocabulary');
  }

  unset($vocabulary->original);
  cache_clear_all();

  return $status;
}

/**
 * Deletes a vocabulary.
 *
 * This will update all dnp fields so that they don't reference the
 * deleted vocabulary. It also will delete fields that have no remaining
 * vocabulary references. All dnp terms of the deleted vocabulary
 * will be deleted as well.
 *
 * @param $vid
 *   A vocabulary ID.
 * @return
 *   Constant indicating items were deleted.
 */
function dnp_vocabulary_delete($vid) {
  $vocabulary = dnp_vocabulary_load($vid);

  $transaction = db_transaction();
  try {
    // Only load terms without a parent, child terms will get deleted too.
    $result = db_query('SELECT t.tid FROM {dnp_term_data} t INNER JOIN {dnp_term_hierarchy} th ON th.tid = t.tid WHERE t.vid = :vid AND th.parent = 0', array(':vid' => $vid))->fetchCol();
    foreach ($result as $tid) {
      dnp_term_delete($tid);
    }
    db_delete('dnp_vocabulary')
      ->condition('vid', $vid)
      ->execute();

    field_attach_delete_bundle('dnp_term', $vocabulary->machine_name);
    module_invoke_all('dnp_vocabulary_delete', $vocabulary);
    module_invoke_all('entity_delete', $vocabulary, 'dnp_vocabulary');

    // Load all dnp module fields and delete those which use only this
    // vocabulary.
    $dnp_fields = field_read_fields(array('module' => 'dnp'));
    foreach ($dnp_fields as $field_name => $dnp_field) {
      $modified_field = FALSE;
      // Term reference fields may reference terms from more than one
      // vocabulary.
      foreach ($dnp_field['settings']['allowed_values'] as $key => $allowed_value) {
        if ($allowed_value['vocabulary'] == $vocabulary->machine_name) {
          unset($dnp_field['settings']['allowed_values'][$key]);
          $modified_field = TRUE;
        }
      }
      if ($modified_field) {
        if (empty($dnp_field['settings']['allowed_values'])) {
          field_delete_field($field_name);
        }
        else {
          // Update the field definition with the new allowed values.
          field_update_field($dnp_field);
        }
      }
    }

    cache_clear_all();
    dnp_vocabulary_static_reset();

    return SAVED_DELETED;
  }
  catch (Exception $e) {
    $transaction->rollback();
    watchdog_exception('dnp', $e);
    throw $e;
  }
}

/**
 * Implements hook_dnp_vocabulary_update().
 */
function dnp_dnp_vocabulary_update($vocabulary) {
  // Reflect machine name changes in the definitions of existing 'dnp'
  // fields.
  if (!empty($vocabulary->old_machine_name) && $vocabulary->old_machine_name != $vocabulary->machine_name) {
    $fields = field_read_fields();
    foreach ($fields as $field_name => $field) {
      $update = FALSE;
      if ($field['type'] == 'dnp_term_reference') {
        foreach ($field['settings']['allowed_values'] as $key => &$value) {
          if ($value['vocabulary'] == $vocabulary->old_machine_name) {
            $value['vocabulary'] = $vocabulary->machine_name;
            $update = TRUE;
          }
        }
        if ($update) {
          field_update_field($field);
        }
      }
    }
  }
}

/**
 * Checks and updates the hierarchy flag of a vocabulary.
 *
 * Checks the current parents of all terms in a vocabulary and updates the
 * vocabulary's hierarchy setting to the lowest possible level. If no term
 * has parent terms then the vocabulary will be given a hierarchy of 0.
 * If any term has a single parent then the vocabulary will be given a
 * hierarchy of 1. If any term has multiple parents then the vocabulary
 * will be given a hierarchy of 2.
 *
 * @param $vocabulary
 *   A vocabulary object.
 * @param $changed_term
 *   An array of the term structure that was updated.
 *
 * @return
 *   An integer that represents the level of the vocabulary's hierarchy.
 */
function dnp_check_vocabulary_hierarchy($vocabulary, $changed_term) {
  $tree = dnp_get_tree($vocabulary->vid);
  $hierarchy = 0;
  foreach ($tree as $term) {
    // Update the changed term with the new parent value before comparison.
    if ($term->tid == $changed_term['tid']) {
      $term = (object) $changed_term;
      $term->parents = $term->parent;
    }
    // Check this term's parent count.
    if (count($term->parents) > 1) {
      $hierarchy = 2;
      break;
    }
    elseif (count($term->parents) == 1 && !isset($term->parents[0])) {
      $hierarchy = 1;
    }
  }
  if ($hierarchy != $vocabulary->hierarchy) {
    $vocabulary->hierarchy = $hierarchy;
    dnp_vocabulary_save($vocabulary);
  }

  return $hierarchy;
}

/**
 * Saves a term object to the database.
 *
 * @param $term
 *   The dnp term object with the following properties:
 *   - vid: The ID of the vocabulary the term is assigned to.
 *   - name: The name of the term.
 *   - tid: (optional) The unique ID for the term being saved. If $term->tid is
 *     empty or omitted, a new term will be inserted.
 *   - description: (optional) The term's description.
 *   - format: (optional) The text format for the term's description.
 *   - weight: (optional) The weight of this term in relation to other terms
 *     within the same vocabulary.
 *   - parent: (optional) The parent term(s) for this term. This can be a single
 *     term ID or an array of term IDs. A value of 0 means this term does not
 *     have any parents. When omitting this variable during an update, the
 *     existing hierarchy for the term remains unchanged.
 *   - vocabulary_machine_name: (optional) The machine name of the vocabulary
 *     the term is assigned to. If not given, this value will be set
 *     automatically by loading the vocabulary based on $term->vid.
 *   - original: (optional) The original dnp term object before any changes
 *     were applied. When omitted, the unchanged dnp term object is
 *     loaded from the database and stored in this property.
 *   Since a dnp term is an entity, any fields contained in the term object
 *   are saved alongside the term object.
 *
 * @return
 *   Status constant indicating whether term was inserted (SAVED_NEW) or updated
 *   (SAVED_UPDATED). When inserting a new term, $term->tid will contain the
 *   term ID of the newly created term.
 */
function dnp_term_save($term) {
  // Prevent leading and trailing spaces in term names.
  $term->name = trim($term->name);
  if (!isset($term->vocabulary_machine_name)) {
    $vocabulary = dnp_vocabulary_load($term->vid);
    $term->vocabulary_machine_name = $vocabulary->machine_name;
  }

  // Load the stored entity, if any.
  if (!empty($term->tid) && !isset($term->original)) {
    $term->original = entity_load_unchanged('dnp_term', $term->tid);
  }

  field_attach_presave('dnp_term', $term);
  module_invoke_all('dnp_term_presave', $term);
  module_invoke_all('entity_presave', $term, 'dnp_term');

  if (empty($term->tid)) {
    $op = 'insert';
    $status = drupal_write_record('dnp_term_data', $term);
    field_attach_insert('dnp_term', $term);
    if (!isset($term->parent)) {
      $term->parent = array(0);
    }
  }
  else {
    $op = 'update';
    $status = drupal_write_record('dnp_term_data', $term, 'tid');
    field_attach_update('dnp_term', $term);
    if (isset($term->parent)) {
      db_delete('dnp_term_hierarchy')
        ->condition('tid', $term->tid)
        ->execute();
    }
  }

  if (isset($term->parent)) {
    if (!is_array($term->parent)) {
      $term->parent = array($term->parent);
    }
    $query = db_insert('dnp_term_hierarchy')
      ->fields(array('tid', 'parent'));
    foreach ($term->parent as $parent) {
      if (is_array($parent)) {
        foreach ($parent as $tid) {
          $query->values(array(
            'tid' => $term->tid,
            'parent' => $tid
          ));
        }
      }
      else {
        $query->values(array(
          'tid' => $term->tid,
          'parent' => $parent
        ));
      }
    }
    $query->execute();
  }

  // Reset the dnp term static variables.
  dnp_terms_static_reset();

  // Invoke the dnp hooks.
  module_invoke_all("dnp_term_$op", $term);
  module_invoke_all("entity_$op", $term, 'dnp_term');
  unset($term->original);

  return $status;
}

/**
 * Delete a term.
 *
 * @param $tid
 *   The term ID.
 * @return
 *   Status constant indicating deletion.
 */
function dnp_term_delete($tid) {
  $transaction = db_transaction();
  try {
    $tids = array($tid);
    while ($tids) {
      $children_tids = $orphans = array();
      foreach ($tids as $tid) {
        // See if any of the term's children are about to be become orphans:
        if ($children = dnp_get_children($tid)) {
          foreach ($children as $child) {
            // If the term has multiple parents, we don't delete it.
            $parents = dnp_get_parents($child->tid);
            if (count($parents) == 1) {
              $orphans[] = $child->tid;
            }
          }
        }

        if ($term = dnp_term_load($tid)) {
          db_delete('dnp_term_data')
            ->condition('tid', $tid)
            ->execute();
          db_delete('dnp_term_hierarchy')
            ->condition('tid', $tid)
            ->execute();

          field_attach_delete('dnp_term', $term);
          module_invoke_all('dnp_term_delete', $term);
          module_invoke_all('entity_delete', $term, 'dnp_term');
          dnp_terms_static_reset();
        }
      }

      $tids = $orphans;
    }
    return SAVED_DELETED;
  }
  catch (Exception $e) {
    $transaction->rollback();
    watchdog_exception('dnp', $e);
    throw $e;
  }
}

/**
 * Generates an array which displays a term detail page.
 *
 * @param term
 *   A dnp term object.
 * @return
 *   A $page element suitable for use by drupal_render().
 */
function dnp_term_show($term) {
  return dnp_term_view_multiple(array($term->tid => $term), 'full');
}

/**
 * Constructs a drupal_render() style array from an array of loaded terms.
 *
 * @param $terms
 *   An array of dnp terms as returned by dnp_term_load_multiple().
 * @param $view_mode
 *   View mode, e.g. 'full', 'teaser'...
 * @param $weight
 *   An integer representing the weight of the first dnp term in the list.
 * @param $langcode
 *   (optional) A language code to use for rendering. Defaults to the global
 *   content language of the current request.
 *
 * @return
 *   An array in the format expected by drupal_render().
 */
function dnp_term_view_multiple($terms, $view_mode = 'teaser', $weight = 0, $langcode = NULL) {
  $build = array();
  $entities_by_view_mode = entity_view_mode_prepare('dnp_term', $terms, $view_mode, $langcode);
  foreach ($entities_by_view_mode as $entity_view_mode => $entities) {
    field_attach_prepare_view('dnp_term', $entities, $entity_view_mode, $langcode);
    entity_prepare_view('dnp_term', $entities, $langcode);

    foreach ($entities as $entity) {
      $build['dnp_terms'][$entity->tid] = dnp_term_view($entity, $entity_view_mode, $langcode);
    }
  }

  foreach ($terms as $term) {
    $build['dnp_terms'][$term->tid]['#weight'] = $weight;
    $weight++;
  }
  // Sort here, to preserve the input order of the entities that were passed to
  // this function.
  uasort($build['dnp_terms'], 'element_sort');
  $build['dnp_terms']['#sorted'] = TRUE;

  return $build;
}

/**
 * Builds a structured array representing the term's content.
 *
 * The content built for the dnp term (field values, file attachments or
 * other term components) will vary depending on the $view_mode parameter.
 *
 * Drupal core defines the following view modes for terms, with the following
 * default use cases:
 *   - full (default): term is displayed on its own page (dnp/term/123)
 * Contributed modules might define additional view modes, or use existing
 * view modes in additional contexts.
 *
 * @param $term
 *   A dnp term object.
 * @param $view_mode
 *   View mode, e.g. 'full', 'teaser'...
 * @param $langcode
 *   (optional) A language code to use for rendering. Defaults to the global
 *   content language of the current request.
 */
function dnp_term_build_content($term, $view_mode = 'full', $langcode = NULL) {
  if (!isset($langcode)) {
    $langcode = $GLOBALS['language_content']->language;
  }

  // Remove previously built content, if exists.
  $term->content = array();

  // Allow modules to change the view mode.
  $view_mode = key(entity_view_mode_prepare('dnp_term', array($term->tid => $term), $view_mode, $langcode));

  // Add the term description if the term has one and it is visible.
  $type = 'dnp_term';
  $entity_ids = entity_extract_ids($type, $term);
  $settings = field_view_mode_settings($type, $entity_ids[2]);
  $fields = field_extra_fields_get_display($type, $entity_ids[2], $view_mode);
  if (!empty($term->description) && isset($fields['description']) && $fields['description']['visible']) {
    $term->content['description'] = array(
      '#markup' => check_markup($term->description, $term->format, '', TRUE),
      '#weight' => $fields['description']['weight'],
      '#prefix' => '<div class="dnp-term-description">',
      '#suffix' => '</div>',
    );
  }

  // Build fields content.
  // In case of a multiple view, dnp_term_view_multiple() already ran the
  // 'prepare_view' step. An internal flag prevents the operation from running
  // twice.
  field_attach_prepare_view('dnp_term', array($term->tid => $term), $view_mode, $langcode);
  entity_prepare_view('dnp_term', array($term->tid => $term), $langcode);
  $term->content += field_attach_view('dnp_term', $term, $view_mode, $langcode);

  // Allow modules to make their own additions to the dnp term.
  module_invoke_all('dnp_term_view', $term, $view_mode, $langcode);
  module_invoke_all('entity_view', $term, 'dnp_term', $view_mode, $langcode);

  // Make sure the current view mode is stored if no module has already
  // populated the related key.
  $term->content += array('#view_mode' => $view_mode);
}

/**
 * Generate an array for rendering the given term.
 *
 * @param $term
 *   A term object.
 * @param $view_mode
 *   View mode, e.g. 'full', 'teaser'...
 * @param $langcode
 *   (optional) A language code to use for rendering. Defaults to the global
 *   content language of the current request.
 *
 * @return
 *   An array as expected by drupal_render().
 */
function dnp_term_view($term, $view_mode = 'full', $langcode = NULL) {
  if (!isset($langcode)) {
    $langcode = $GLOBALS['language_content']->language;
  }

  // Populate $term->content with a render() array.
  dnp_term_build_content($term, $view_mode, $langcode);
  $build = $term->content;

  // We don't need duplicate rendering info in $term->content.
  unset($term->content);

  $build += array(
    '#theme' => 'dnp_term',
    '#term' => $term,
    '#view_mode' => $view_mode,
    '#language' => $langcode,
  );

  $build['#attached']['css'][] = drupal_get_path('module', 'dnp') . '/dnp.css';

  // Allow modules to modify the structured dnp term.
  $type = 'dnp_term';
  drupal_alter(array('dnp_term_view', 'entity_view'), $build, $type);

  return $build;
}

/**
 * Process variables for dnp-term.tpl.php.
 */
function template_preprocess_dnp_term(&$variables) {
  $variables['view_mode'] = $variables['elements']['#view_mode'];
  $variables['term'] = $variables['elements']['#term'];
  $term = $variables['term'];

  $uri = entity_uri('dnp_term', $term);
  $variables['term_url']  = url($uri['path'], $uri['options']);
  $variables['term_name'] = check_plain($term->name);
  $variables['page']      = $variables['view_mode'] == 'full' && dnp_term_is_page($term);

  // Flatten the term object's member fields.
  $variables = array_merge((array) $term, $variables);

  // Helpful $content variable for templates.
  $variables['content'] = array();
  foreach (element_children($variables['elements']) as $key) {
    $variables['content'][$key] = $variables['elements'][$key];
  }

  // field_attach_preprocess() overwrites the $[field_name] variables with the
  // values of the field in the language that was selected for display, instead
  // of the raw values in $term->[field_name], which contain all values in all
  // languages.
  field_attach_preprocess('dnp_term', $term, $variables['content'], $variables);

  // Gather classes, and clean up name so there are no underscores.
  $vocabulary_name_css = str_replace('_', '-', $term->vocabulary_machine_name);
  $variables['classes_array'][] = 'vocabulary-' . $vocabulary_name_css;

  $variables['theme_hook_suggestions'][] = 'dnp_term__' . $term->vocabulary_machine_name;
  $variables['theme_hook_suggestions'][] = 'dnp_term__' . $term->tid;
}

/**
 * Returns whether the current page is the page of the passed-in term.
 *
 * @param $term
 *   A term object.
 */
function dnp_term_is_page($term) {
  $page_term = menu_get_object('dnp_term', 2);
  return (!empty($page_term) ? $page_term->tid == $term->tid : FALSE);
}

/**
 * Clear all static cache variables for terms.
 */
function dnp_terms_static_reset() {
  drupal_static_reset('dnp_term_count_nodes');
  drupal_static_reset('dnp_get_tree');
  drupal_static_reset('dnp_get_tree:parents');
  drupal_static_reset('dnp_get_tree:terms');
  drupal_static_reset('dnp_get_parents');
  drupal_static_reset('dnp_get_parents_all');
  drupal_static_reset('dnp_get_children');
  entity_get_controller('dnp_term')->resetCache();
}

/**
 * Clear all static cache variables for vocabularies.
 *
 * @param $ids
 * An array of ids to reset in entity controller cache.
 */
function dnp_vocabulary_static_reset($ids = NULL) {
  drupal_static_reset('dnp_vocabulary_get_names');
  entity_get_controller('dnp_vocabulary')->resetCache($ids);
}

/**
 * Return an array of all vocabulary objects.
 *
 * @return
 *   An array of all vocabulary objects, indexed by vid.
 */
function dnp_get_vocabularies() {
  return dnp_vocabulary_load_multiple(FALSE, array());
}

/**
 * Get names for all dnp vocabularies.
 *
 * @return
 *   An associative array of objects keyed by vocabulary machine name with
 *   information about dnp vocabularies. Each object has properties:
 *   - name: The vocabulary name.
 *   - machine_name: The machine name.
 *   - vid: The vocabulary ID.
 */
function dnp_vocabulary_get_names() {
  $names = &drupal_static(__FUNCTION__);

  if (!isset($names)) {
    $names = db_query('SELECT name, machine_name, vid FROM {dnp_vocabulary}')->fetchAllAssoc('machine_name');
  }

  return $names;
}

/**
 * Finds all parents of a given term ID.
 *
 * @param $tid
 *   A dnp term ID.
 *
 * @return
 *   An array of term objects which are the parents of the term $tid, or an
 *   empty array if parents are not found.
 */
function dnp_get_parents($tid) {
  $parents = &drupal_static(__FUNCTION__, array());

  if ($tid && !isset($parents[$tid])) {
    $query = db_select('dnp_term_data', 't');
    $query->join('dnp_term_hierarchy', 'h', 'h.parent = t.tid');
    $query->addField('t', 'tid');
    $query->condition('h.tid', $tid);
    $query->addTag('term_access');
    $query->orderBy('t.weight');
    $query->orderBy('t.name');
    $tids = $query->execute()->fetchCol();
    $parents[$tid] = dnp_term_load_multiple($tids);
  }

  return isset($parents[$tid]) ? $parents[$tid] : array();
}

/**
 * Find all ancestors of a given term ID.
 */
function dnp_get_parents_all($tid) {
  $cache = &drupal_static(__FUNCTION__, array());

  if (isset($cache[$tid])) {
    return $cache[$tid];
  }

  $parents = array();
  if ($term = dnp_term_load($tid)) {
    $parents[] = $term;
    $n = 0;
    while ($parent = dnp_get_parents($parents[$n]->tid)) {
      $parents = array_merge($parents, $parent);
      $n++;
    }
  }

  $cache[$tid] = $parents;

  return $parents;
}

/**
 * Finds all children of a term ID.
 *
 * @param $tid
 *   A dnp term ID.
 * @param $vid
 *   An optional vocabulary ID to restrict the child search.
 *
 * @return
 *   An array of term objects that are the children of the term $tid, or an
 *   empty array when no children exist.
 */
function dnp_get_children($tid, $vid = 0) {
  $children = &drupal_static(__FUNCTION__, array());

  if ($tid && !isset($children[$tid])) {
    $query = db_select('dnp_term_data', 't');
    $query->join('dnp_term_hierarchy', 'h', 'h.tid = t.tid');
    $query->addField('t', 'tid');
    $query->condition('h.parent', $tid);
    if ($vid) {
      $query->condition('t.vid', $vid);
    }
    $query->addTag('term_access');
    $query->orderBy('t.weight');
    $query->orderBy('t.name');
    $tids = $query->execute()->fetchCol();
    $children[$tid] = dnp_term_load_multiple($tids);
  }

  return isset($children[$tid]) ? $children[$tid] : array();
}

/**
 * Create a hierarchical representation of a vocabulary.
 *
 * @param $vid
 *   Which vocabulary to generate the tree for.
 * @param $parent
 *   The term ID under which to generate the tree. If 0, generate the tree
 *   for the entire vocabulary.
 * @param $max_depth
 *   The number of levels of the tree to return. Leave NULL to return all levels.
 * @param $load_entities
 *   If TRUE, a full entity load will occur on the term objects. Otherwise they
 *   are partial objects queried directly from the {dnp_term_data} table to
 *   save execution time and memory consumption when listing large numbers of
 *   terms. Defaults to FALSE.
 *
 * @return
 *   An array of all term objects in the tree. Each term object is extended
 *   to have "depth" and "parents" attributes in addition to its normal ones.
 *   Results are statically cached. Term objects will be partial or complete
 *   depending on the $load_entities parameter.
 */
function dnp_get_tree($vid, $parent = 0, $max_depth = NULL, $load_entities = FALSE) {
  $children = &drupal_static(__FUNCTION__, array());
  $parents = &drupal_static(__FUNCTION__ . ':parents', array());
  $terms = &drupal_static(__FUNCTION__ . ':terms', array());

  // We cache trees, so it's not CPU-intensive to call dnp_get_tree() on a
  // term and its children, too.
  if (!isset($children[$vid])) {
    $children[$vid] = array();
    $parents[$vid] = array();
    $terms[$vid] = array();

    $query = db_select('dnp_term_data', 't');
    $query->join('dnp_term_hierarchy', 'h', 'h.tid = t.tid');
    $result = $query
      ->addTag('translatable')
      ->addTag('term_access')
      ->fields('t')
      ->fields('h', array('parent'))
      ->condition('t.vid', $vid)
      ->orderBy('t.weight')
      ->orderBy('t.name')
      ->execute();

    foreach ($result as $term) {
      $children[$vid][$term->parent][] = $term->tid;
      $parents[$vid][$term->tid][] = $term->parent;
      $terms[$vid][$term->tid] = $term;
    }
  }

  // Load full entities, if necessary. The entity controller statically
  // caches the results.
  if ($load_entities) {
    $term_entities = dnp_term_load_multiple(array_keys($terms[$vid]));
  }

  $max_depth = (!isset($max_depth)) ? count($children[$vid]) : $max_depth;
  $tree = array();

  // Keeps track of the parents we have to process, the last entry is used
  // for the next processing step.
  $process_parents = array();
  $process_parents[] = $parent;

  // Loops over the parent terms and adds its children to the tree array.
  // Uses a loop instead of a recursion, because it's more efficient.
  while (count($process_parents)) {
    $parent = array_pop($process_parents);
    // The number of parents determines the current depth.
    $depth = count($process_parents);
    if ($max_depth > $depth && !empty($children[$vid][$parent])) {
      $has_children = FALSE;
      $child = current($children[$vid][$parent]);
      do {
        if (empty($child)) {
          break;
        }
        $term = $load_entities ? $term_entities[$child] : $terms[$vid][$child];
        if (isset($parents[$vid][$term->tid])) {
          // Clone the term so that the depth attribute remains correct
          // in the event of multiple parents.
          $term = clone $term;
        }
        $term->depth = $depth;
        unset($term->parent);
        $term->parents = $parents[$vid][$term->tid];
        $tree[] = $term;
        if (!empty($children[$vid][$term->tid])) {
          $has_children = TRUE;

          // We have to continue with this parent later.
          $process_parents[] = $parent;
          // Use the current term as parent for the next iteration.
          $process_parents[] = $term->tid;

          // Reset pointers for child lists because we step in there more often
          // with multi parents.
          reset($children[$vid][$term->tid]);
          // Move pointer so that we get the correct term the next time.
          next($children[$vid][$parent]);
          break;
        }
      } while ($child = next($children[$vid][$parent]));

      if (!$has_children) {
        // We processed all terms in this hierarchy-level, reset pointer
        // so that this function works the next time it gets called.
        reset($children[$vid][$parent]);
      }
    }
  }

  return $tree;
}

/**
 * Try to map a string to an existing term, as for glossary use.
 *
 * Provides a case-insensitive and trimmed mapping, to maximize the
 * likelihood of a successful match.
 *
 * @param $name
 *   Name of the term to search for.
 * @param $vocabulary
 *   (optional) Vocabulary machine name to limit the search. Defaults to NULL.
 *
 * @return
 *   An array of matching term objects.
 */
function dnp_get_term_by_name($name, $vocabulary = NULL) {
  $conditions = array('name' => trim($name));
  if (isset($vocabulary)) {
    $vocabularies = dnp_vocabulary_get_names();
    if (isset($vocabularies[$vocabulary])) {
      $conditions['vid'] = $vocabularies[$vocabulary]->vid;
    }
    else {
      // Return an empty array when filtering by a non-existing vocabulary.
      return array();
    }
  }
  return dnp_term_load_multiple(array(), $conditions);
}

/**
 * Controller class for dnp terms.
 *
 * This extends the DrupalDefaultEntityController class. Only alteration is
 * that we match the condition on term name case-independently.
 */
class dnpTermController extends DrupalDefaultEntityController {

  protected function buildQuery($ids, $conditions = array(), $revision_id = FALSE) {
    $query = parent::buildQuery($ids, $conditions, $revision_id);
    $query->addTag('translatable');
    $query->addTag('term_access');
    // When name is passed as a condition use LIKE.
    if (isset($conditions['name'])) {
      $query_conditions = &$query->conditions();
      foreach ($query_conditions as $key => $condition) {
        if (is_array($condition) && $condition['field'] == 'base.name') {
          $query_conditions[$key]['operator'] = 'LIKE';
          $query_conditions[$key]['value'] = db_like($query_conditions[$key]['value']);
        }
      }
    }
    // Add the machine name field from the {dnp_vocabulary} table.
    $query->innerJoin('dnp_vocabulary', 'v', 'base.vid = v.vid');
    $query->addField('v', 'machine_name', 'vocabulary_machine_name');
    return $query;
  }

  protected function cacheGet($ids, $conditions = array()) {
    $terms = parent::cacheGet($ids, $conditions);
    // Name matching is case insensitive, note that with some collations
    // LOWER() and drupal_strtolower() may return different results.
    foreach ($terms as $term) {
      $term_values = (array) $term;
      if (isset($conditions['name']) && drupal_strtolower($conditions['name'] != drupal_strtolower($term_values['name']))) {
        unset($terms[$term->tid]);
      }
    }
    return $terms;
  }
}

/**
 * Controller class for dnp vocabularies.
 *
 * This extends the DrupalDefaultEntityController class, adding required
 * special handling for dnp vocabulary objects.
 */
class dnpVocabularyController extends DrupalDefaultEntityController {

  protected function buildQuery($ids, $conditions = array(), $revision_id = FALSE) {
    $query = parent::buildQuery($ids, $conditions, $revision_id);
    $query->addTag('translatable');
    $query->orderBy('base.weight');
    $query->orderBy('base.name');
    return $query;
  }
}

/**
 * Load multiple dnp terms based on certain conditions.
 *
 * This function should be used whenever you need to load more than one term
 * from the database. Terms are loaded into memory and will not require
 * database access if loaded again during the same page request.
 *
 * @see entity_load()
 * @see EntityFieldQuery
 *
 * @param $tids
 *   An array of dnp term IDs.
 * @param $conditions
 *   (deprecated) An associative array of conditions on the {dnp_term}
 *   table, where the keys are the database fields and the values are the
 *   values those fields must have. Instead, it is preferable to use
 *   EntityFieldQuery to retrieve a list of entity IDs loadable by
 *   this function.
 *
 * @return
 *   An array of term objects, indexed by tid. When no results are found, an
 *   empty array is returned.
 *
 * @todo Remove $conditions in Drupal 8.
 */
function dnp_term_load_multiple($tids = array(), $conditions = array()) {
  return entity_load('dnp_term', $tids, $conditions);
}

/**
 * Load multiple dnp vocabularies based on certain conditions.
 *
 * This function should be used whenever you need to load more than one
 * vocabulary from the database. Terms are loaded into memory and will not
 * require database access if loaded again during the same page request.
 *
 * @see entity_load()
 *
 * @param $vids
 *  An array of dnp vocabulary IDs, or FALSE to load all vocabularies.
 * @param $conditions
 *  An array of conditions to add to the query.
 *
 * @return
 *  An array of vocabulary objects, indexed by vid.
 */
function dnp_vocabulary_load_multiple($vids = array(), $conditions = array()) {
  return entity_load('dnp_vocabulary', $vids, $conditions);
}

/**
 * Return the vocabulary object matching a vocabulary ID.
 *
 * @param $vid
 *   The vocabulary's ID.
 *
 * @return
 *   The vocabulary object with all of its metadata, if exists, FALSE otherwise.
 *   Results are statically cached.
 *
 * @see dnp_vocabulary_machine_name_load()
 */
function dnp_vocabulary_load($vid) {
  $vocabularies = dnp_vocabulary_load_multiple(array($vid));
  return reset($vocabularies);
}

/**
 * Return the vocabulary object matching a vocabulary machine name.
 *
 * @param $name
 *   The vocabulary's machine name.
 *
 * @return
 *   The vocabulary object with all of its metadata, if exists, FALSE otherwise.
 *   Results are statically cached.
 *
 * @see dnp_vocabulary_load()
 */
function dnp_vocabulary_machine_name_load($name) {
  $vocabularies = dnp_vocabulary_load_multiple(NULL, array('machine_name' => $name));
  return reset($vocabularies);
}

/**
 * Return the term object matching a term ID.
 *
 * @param $tid
 *   A term's ID
 *
 * @return
 *   A dnp term object, or FALSE if the term was not found. Results are
 *   statically cached.
 */
function dnp_term_load($tid) {
  if (!is_numeric($tid)) {
    return FALSE;
  }
  $term = dnp_term_load_multiple(array($tid), array());
  return $term ? $term[$tid] : FALSE;
}

/**
 * Helper function for array_map purposes.
 */
function _dnp_get_tid_from_term($term) {
  return $term->tid;
}

/**
 * Implodes a list of tags of a certain vocabulary into a string.
 *
 * @see drupal_explode_tags()
 */
function dnp_implode_tags($tags, $vid = NULL) {
  $typed_tags = array();
  foreach ($tags as $tag) {
    // Extract terms belonging to the vocabulary in question.
    if (!isset($vid) || $tag->vid == $vid) {
      // Make sure we have a completed loaded dnp term.
      if (isset($tag->name)) {
        // Commas and quotes in tag names are special cases, so encode 'em.
        if (strpos($tag->name, ',') !== FALSE || strpos($tag->name, '"') !== FALSE) {
          $typed_tags[] = '"' . str_replace('"', '""', $tag->name) . '"';
        }
        else {
          $typed_tags[] = $tag->name;
        }
      }
    }
  }
  return implode(', ', $typed_tags);
}

/**
 * Implements hook_field_info().
 *
 * Field settings:
 * - allowed_values: a list array of one or more vocabulary trees:
 *   - vocabulary: a vocabulary machine name.
 *   - parent: a term ID of a term whose children are allowed. This should be
 *     '0' if all terms in a vocabulary are allowed. The allowed values do not
 *     include the parent term.
 *
 */
function dnp_field_info() {
  return array(
    'dnp_term_reference' => array(
      'label' => t('Dnp reference'),
      'description' => t('This field stores a reference to a dnp term.'),
      'default_widget' => 'options_select',
      'default_formatter' => 'dnp_term_reference_link',
      'settings' => array(
        'allowed_values' => array(
          array(
            'vocabulary' => '',
            'parent' => '0',
          ),
        ),
      ),
    ),
  );
}

/**
 * Implements hook_field_widget_info().
 */
function dnp_field_widget_info() {
  return array(
    'dnp_autocomplete' => array(
      'label' => t('Autocomplete term widget (tagging)'),
      'field types' => array('dnp_term_reference'),
      'settings' => array(
        'size' => 60,
        'autocomplete_path' => 'dnp/autocomplete',
      ),
      'behaviors' => array(
        'multiple values' => FIELD_BEHAVIOR_CUSTOM,
      ),
    ),
  );
}

/**
 * Implements hook_field_widget_info_alter().
 */
function dnp_field_widget_info_alter(&$info) {
  $info['options_select']['field types'][] = 'dnp_term_reference';
  $info['options_buttons']['field types'][] = 'dnp_term_reference';
}

/**
 * Implements hook_options_list().
 */
function dnp_options_list($field, $instance, $entity_type, $entity) {
  $function = !empty($field['settings']['options_list_callback']) ? $field['settings']['options_list_callback'] : 'dnp_allowed_values';
  return $function($field);
}

/**
 * Implements hook_field_validate().
 *
 * dnp field settings allow for either a single vocabulary ID, multiple
 * vocabulary IDs, or sub-trees of a vocabulary to be specified as allowed
 * values, although only the first of these is supported via the field UI.
 * Confirm that terms entered as values meet at least one of these conditions.
 *
 * Possible error codes:
 * - 'dnp_term_illegal_value': The value is not part of the list of allowed values.
 */
function dnp_field_validate($entity_type, $entity, $field, $instance, $langcode, $items, &$errors) {
  // Build an array of existing term IDs so they can be loaded with
  // dnp_term_load_multiple();
  foreach ($items as $delta => $item) {
    if (!empty($item['tid']) && $item['tid'] != 'autocreate') {
      $tids[] = $item['tid'];
    }
  }
  if (!empty($tids)) {
    $terms = dnp_term_load_multiple($tids);

    // Check each existing item to ensure it can be found in the
    // allowed values for this field.
    foreach ($items as $delta => $item) {
      $validate = TRUE;
      if (!empty($item['tid']) && $item['tid'] != 'autocreate') {
        $validate = FALSE;
        foreach ($field['settings']['allowed_values'] as $settings) {
          // If no parent is specified, check if the term is in the vocabulary.
          if (isset($settings['vocabulary']) && empty($settings['parent'])) {
            if ($settings['vocabulary'] == $terms[$item['tid']]->vocabulary_machine_name) {
              $validate = TRUE;
              break;
            }
          }
          // If a parent is specified, then to validate it must appear in the
          // array returned by dnp_get_parents_all().
          elseif (!empty($settings['parent'])) {
            $ancestors = dnp_get_parents_all($item['tid']);
            foreach ($ancestors as $ancestor) {
              if ($ancestor->tid == $settings['parent']) {
                $validate = TRUE;
                break 2;
              }
            }
          }
        }
      }
      if (!$validate) {
        $errors[$field['field_name']][$langcode][$delta][] = array(
          'error' => 'dnp_term_reference_illegal_value',
          'message' => t('%name: illegal value.', array('%name' => $instance['label'])),
        );
      }
    }
  }
}

/**
 * Implements hook_field_is_empty().
 */
function dnp_field_is_empty($item, $field) {
  if (!is_array($item) || (empty($item['tid']) && (string) $item['tid'] !== '0')) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Implements hook_field_formatter_info().
 */
function dnp_field_formatter_info() {
  return array(
    'dnp_term_reference_link' => array(
      'label' => t('Link'),
      'field types' => array('dnp_term_reference'),
    ),
    'dnp_term_reference_plain' => array(
      'label' => t('Plain text'),
      'field types' => array('dnp_term_reference'),
    ),
    'dnp_term_reference_rss_category' => array(
      'label' => t('RSS category'),
      'field types' => array('dnp_term_reference'),
    ),
  );
}

/**
 * Implements hook_field_formatter_view().
 */
function dnp_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  $element = array();

  // Terms whose tid is 'autocreate' do not exist
  // yet and $item['dnp_term'] is not set. Theme such terms as
  // just their name.

  switch ($display['type']) {
    case 'dnp_term_reference_link':
      foreach ($items as $delta => $item) {
        if ($item['tid'] == 'autocreate') {
          $element[$delta] = array(
            '#markup' => check_plain($item['name']),
          );
        }
        else {
          $term = $item['dnp_term'];
          $uri = entity_uri('dnp_term', $term);
          $element[$delta] = array(
            '#type' => 'link',
            '#title' => $term->name,
            '#href' => $uri['path'],
            '#options' => $uri['options'],
          );
        }
      }
      break;

    case 'dnp_term_reference_plain':
      foreach ($items as $delta => $item) {
        $name = ($item['tid'] != 'autocreate' ? $item['dnp_term']->name : $item['name']);
        $element[$delta] = array(
          '#markup' => check_plain($name),
        );
      }
      break;

    case 'dnp_term_reference_rss_category':
      foreach ($items as $delta => $item) {
        $entity->rss_elements[] = array(
          'key' => 'category',
          'value' => $item['tid'] != 'autocreate' ? $item['dnp_term']->name : $item['name'],
          'attributes' => array(
            'domain' => $item['tid'] != 'autocreate' ? url('dnp/term/' . $item['tid'], array('absolute' => TRUE)) : '',
          ),
        );
      }
      break;
  }

  return $element;
}

/**
 * Returns the set of valid terms for a dnp field.
 *
 * @param $field
 *   The field definition.
 * @return
 *   The array of valid terms for this field, keyed by term id.
 */
function dnp_allowed_values($field) {
  $options = array();
  foreach ($field['settings']['allowed_values'] as $tree) {
    if ($vocabulary = dnp_vocabulary_machine_name_load($tree['vocabulary'])) {
      if ($terms = dnp_get_tree($vocabulary->vid, $tree['parent'])) {
        foreach ($terms as $term) {
          $options[$term->tid] = str_repeat('-', $term->depth) . $term->name;
        }
      }
    }
  }
  return $options;
}

/**
 * Implements hook_field_formatter_prepare_view().
 *
 * This preloads all dnp terms for multiple loaded objects at once and
 * unsets values for invalid terms that do not exist.
 */
function dnp_field_formatter_prepare_view($entity_type, $entities, $field, $instances, $langcode, &$items, $displays) {
  $tids = array();

  // Collect every possible term attached to any of the fieldable entities.
  foreach ($entities as $id => $entity) {
    foreach ($items[$id] as $delta => $item) {
      // Force the array key to prevent duplicates.
      if ($item['tid'] != 'autocreate') {
        $tids[$item['tid']] = $item['tid'];
      }
    }
  }
  if ($tids) {
    $terms = dnp_term_load_multiple($tids);

    // Iterate through the fieldable entities again to attach the loaded term data.
    foreach ($entities as $id => $entity) {
      $rekey = FALSE;

      foreach ($items[$id] as $delta => $item) {
        // Check whether the dnp term field instance value could be loaded.
        if (isset($terms[$item['tid']])) {
          // Replace the instance value with the term data.
          $items[$id][$delta]['dnp_term'] = $terms[$item['tid']];
        }
        // Terms to be created are not in $terms, but are still legitimate.
        elseif ($item['tid'] == 'autocreate') {
          // Leave the item in place.
        }
        // Otherwise, unset the instance value, since the term does not exist.
        else {
          unset($items[$id][$delta]);
          $rekey = TRUE;
        }
      }

      if ($rekey) {
        // Rekey the items array.
        $items[$id] = array_values($items[$id]);
      }
    }
  }
}

/**
 * Title callback for term pages.
 *
 * @param $term
 *   A term object.
 *
 * @return
 *   The term name to be used as the page title.
 */
function dnp_term_title($term) {
  return $term->name;
}

/**
 * Implements hook_field_widget_form().
 */
function dnp_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {
  $tags = array();
  foreach ($items as $item) {
    $tags[$item['tid']] = isset($item['dnp_term']) ? $item['dnp_term'] : dnp_term_load($item['tid']);
  }

  $element += array(
    '#type' => 'textfield',
    '#default_value' => dnp_implode_tags($tags),
    '#autocomplete_path' => $instance['widget']['settings']['autocomplete_path'] . '/' . $field['field_name'],
    '#size' => $instance['widget']['settings']['size'],
    '#maxlength' => 1024,
    '#element_validate' => array('dnp_autocomplete_validate'),
  );

  return $element;
}

/**
 * Form element validate handler for dnp term autocomplete element.
 */
function dnp_autocomplete_validate($element, &$form_state) {
  // Autocomplete widgets do not send their tids in the form, so we must detect
  // them here and process them independently.
  $value = array();
  if ($tags = $element['#value']) {
    // Collect candidate vocabularies.
    $field = field_widget_field($element, $form_state);
    $vocabularies = array();
    foreach ($field['settings']['allowed_values'] as $tree) {
      if ($vocabulary = dnp_vocabulary_machine_name_load($tree['vocabulary'])) {
        $vocabularies[$vocabulary->vid] = $vocabulary;
      }
    }

    // Translate term names into actual terms.
    $typed_terms = drupal_explode_tags($tags);
    foreach ($typed_terms as $typed_term) {
      // See if the term exists in the chosen vocabulary and return the tid;
      // otherwise, create a new 'autocreate' term for insert/update.
      if ($possibilities = dnp_term_load_multiple(array(), array('name' => trim($typed_term), 'vid' => array_keys($vocabularies)))) {
        $term = array_pop($possibilities);
      }
      else {
        $vocabulary = reset($vocabularies);
        $term = array(
          'tid' => 'autocreate',
          'vid' => $vocabulary->vid,
          'name' => $typed_term,
          'vocabulary_machine_name' => $vocabulary->machine_name,
        );
      }
      $value[] = (array)$term;
    }
  }

  form_set_value($element, $value, $form_state);
}

/**
 * Implements hook_field_widget_error().
 */
function dnp_field_widget_error($element, $error, $form, &$form_state) {
  form_error($element, $error['message']);
}
/**
 * Implements hook_field_settings_form().
 */
function dnp_field_settings_form($field, $instance, $has_data) {
  // Get proper values for 'allowed_values_function', which is a core setting.
  $vocabularies = dnp_get_vocabularies();
  $options = array();
  foreach ($vocabularies as $vocabulary) {
    $options[$vocabulary->machine_name] = $vocabulary->name;
  }
  $form['allowed_values'] = array(
    '#tree' => TRUE,
  );

  foreach ($field['settings']['allowed_values'] as $delta => $tree) {
    $form['allowed_values'][$delta]['vocabulary'] = array(
      '#type' => 'select',
      '#title' => t('Vocabulary'),
      '#default_value' => $tree['vocabulary'],
      '#options' => $options,
      '#required' => TRUE,
      '#description' => t('The vocabulary which supplies the options for this field.'),
      '#disabled' => $has_data,
    );
    $form['allowed_values'][$delta]['parent'] = array(
      '#type' => 'value',
      '#value' => $tree['parent'],
    );
  }

  return $form;
}

/**
 * Implements hook_rdf_mapping().
 *
 * @return array
 *   The rdf mapping for vocabularies and terms.
 */
function dnp_rdf_mapping() {
  return array(
    array(
      'type' => 'dnp_term',
      'bundle' => RDF_DEFAULT_BUNDLE,
      'mapping' => array(
        'rdftype' => array('skos:Concept'),
        'name'   => array(
          'predicates' => array('rdfs:label', 'skos:prefLabel'),
        ),
        'description'   => array(
          'predicates' => array('skos:definition'),
        ),
        'vid'   => array(
          'predicates' => array('skos:inScheme'),
          'type' => 'rel',
        ),
        'parent'   => array(
          'predicates' => array('skos:broader'),
          'type' => 'rel',
        ),
      ),
    ),
    array(
      'type' => 'dnp_vocabulary',
      'bundle' => RDF_DEFAULT_BUNDLE,
      'mapping' => array(
        'rdftype' => array('skos:ConceptScheme'),
        'name'   => array(
          'predicates' => array('dc:title'),
        ),
        'description'   => array(
          'predicates' => array('rdfs:comment'),
        ),
      ),
    ),
  );
}

/**
 * @defgroup dnp_index dnp indexing
 * @{
 * Functions to maintain dnp indexing.
 *
 * dnp uses default field storage to store canonical relationships
 * between terms and fieldable entities. However its most common use case
 * requires listing all content associated with a term or group of terms
 * sorted by creation date. To avoid slow queries due to joining across
 * multiple node and field tables with various conditions and order by criteria,
 * we maintain a denormalized table with all relationships between terms,
 * published nodes and common sort criteria such as sticky and created.
 * This is used as a lookup table by dnp_select_nodes(). When using other
 * field storage engines or alternative methods of denormalizing this data
 * you should set the variable 'dnp_maintain_index_table' to FALSE
 * to avoid unnecessary writes in SQL.
 */

/**
 * Implements hook_field_presave().
 *
 * Create any new terms defined in a freetagging vocabulary.
 */
function dnp_field_presave($entity_type, $entity, $field, $instance, $langcode, &$items) {
  foreach ($items as $delta => $item) {
    if ($item['tid'] == 'autocreate') {
      $term = (object) $item;
      unset($term->tid);
      dnp_term_save($term);
      $items[$delta]['tid'] = $term->tid;
    }
  }
}

/**
 * Implements hook_node_insert().
 */
function dnp_node_insert($node) {
  // Add dnp index entries for the node.
  dnp_build_node_index($node);
}

/**
 * Builds and inserts dnp index entries for a given node.
 *
 * The index lists all terms that are related to a given node entity, and is
 * therefore maintained at the entity level.
 *
 * @param $node
 *   The node object.
 */
function dnp_build_node_index($node) {
  // We maintain a denormalized table of term/node relationships, containing
  // only data for current, published nodes.
  $status = NULL;
  if (variable_get('dnp_maintain_index_table', TRUE)) {
    // If a node property is not set in the node object when node_save() is
    // called, the old value from $node->original is used.
    if (!empty($node->original)) {
      $status = (int)(!empty($node->status) || (!isset($node->status) && !empty($node->original->status)));
      $sticky = (int)(!empty($node->sticky) || (!isset($node->sticky) && !empty($node->original->sticky)));
    }
    else {
      $status = (int)(!empty($node->status));
      $sticky = (int)(!empty($node->sticky));
    }
  }
  // We only maintain the dnp index for published nodes.
  if ($status) {
    // Collect a unique list of all the term IDs from all node fields.
    $tid_all = array();
    foreach (field_info_instances('node', $node->type) as $instance) {
      $field_name = $instance['field_name'];
      $field = field_info_field($field_name);
      if ($field['module'] == 'dnp' && $field['storage']['type'] == 'field_sql_storage') {
        // If a field value is not set in the node object when node_save() is
        // called, the old value from $node->original is used.
        if (isset($node->{$field_name})) {
          $items = $node->{$field_name};
        }
        elseif (isset($node->original->{$field_name})) {
          $items = $node->original->{$field_name};
        }
        else {
          continue;
        }
        foreach (field_available_languages('node', $field) as $langcode) {
          if (!empty($items[$langcode])) {
            foreach ($items[$langcode] as $item) {
              $tid_all[$item['tid']] = $item['tid'];
            }
          }
        }
      }
    }
    // Insert index entries for all the node's terms.
    if (!empty($tid_all)) {
      $query = db_insert('dnp_index')->fields(array('nid', 'tid', 'sticky', 'created'));
      foreach ($tid_all as $tid) {
        $query->values(array(
          'nid' => $node->nid,
          'tid' => $tid,
          'sticky' => $sticky,
          'created' => $node->created,
        ));
      }
      $query->execute();
    }
  }
}

/**
 * Implements hook_node_update().
 */
function dnp_node_update($node) {
  // Always rebuild the node's dnp index entries on node save.
  dnp_delete_node_index($node);
  dnp_build_node_index($node);
}

/**
 * Implements hook_node_delete().
 */
function dnp_node_delete($node) {
  // Clean up the {dnp_index} table when nodes are deleted.
  dnp_delete_node_index($node);
}

/**
 * Deletes dnp index entries for a given node.
 *
 * @param $node
 *   The node object.
 */
function dnp_delete_node_index($node) {
  if (variable_get('dnp_maintain_index_table', TRUE)) {
    db_delete('dnp_index')->condition('nid', $node->nid)->execute();
  }
}

/**
 * Implements hook_dnp_term_delete().
 */
function dnp_dnp_term_delete($term) {
  if (variable_get('dnp_maintain_index_table', TRUE)) {
    // Clean up the {dnp_index} table when terms are deleted.
    db_delete('dnp_index')->condition('tid', $term->tid)->execute();
  }
}

/**
 * @} End of "defgroup dnp_index".
 */

/**
 * Implements hook_entity_query_alter().
 *
 * Converts EntityFieldQuery instances on dnp terms that have an entity
 * condition on term bundles (vocabulary machine names). Since the vocabulary
 * machine name is not present in the {dnp_term_data} table itself, we have
 * to convert the bundle condition into a property condition of vocabulary IDs
 * to match against {dnp_term_data}.vid.
 */
function dnp_entity_query_alter($query) {
  $conditions = &$query->entityConditions;

  // Alter only dnp term queries with bundle conditions.
  if (isset($conditions['entity_type']) && $conditions['entity_type']['value'] == 'dnp_term' && isset($conditions['bundle'])) {
    // Convert vocabulary machine names to vocabulary IDs.
    $vocabulary_data = dnp_vocabulary_get_names();
    $vids = array();
    if (is_array($conditions['bundle']['value'])) {
      foreach ($conditions['bundle']['value'] as $vocabulary_machine_name) {
        $vids[] = $vocabulary_data[$vocabulary_machine_name]->vid;
      }
    }
    else {
      $vocabulary_machine_name = $conditions['bundle']['value'];
      $vids = $vocabulary_data[$vocabulary_machine_name]->vid;
    }

    $query->propertyCondition('vid', $vids, $conditions['bundle']['operator']);
    unset($conditions['bundle']);
  }
}